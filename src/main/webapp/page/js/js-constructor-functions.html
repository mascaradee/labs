<!DOCTYPE html>
<html lang="ko">
<head>
<title>page title here</title>
<meta charset="utf-8">
<link rel="stylesheet" href="/static/css/style.css"/>
<script>
var obj = {}; // new Object();

/*
 * Object 함수는 대략 이렇게 생김
 
 function Object() {
	if (!(this instanceof Object)) {
		return new Object();
	}
	
	...
 } 
*/

function fn(){ 
	this.age = 40;
	console.log('일반함수');
} // return void(= undefined)
let ffn = fn; // undefined

function Me() {
	// this의 변화
	// 일반 함수로 호출된 함수의 this는 함수를 소유한 (이 경우 최상위 객체인 window) 객체가 된다.
	// 생성자 함수로 호출된 함수의 this는 함수의 소유자가 아니라 앞으로 반환할 새 인스턴스를 의미한다.
	if (!(this instanceof Me)) {
		return new Me();
	}
	this.age = 39;
}
// 메모리 낭비를 방지하기 위해 (런타임 중 내용이 바뀌지 않을) 함수는 프로토타입에 생성한다.
Me.prototype.eat = function(food) {
	console.log('eat', food);
};

let me = new Me();

// 프로토타입 체인
// 인스턴스의 프로퍼티에 접근할 때, 인스턴스에 없는 프로퍼티라면 부모(=프로토타입)에 있는 프로퍼티인지를 자동으로 탐색한다.
// 요것이 프로토타입 체인이다.

me.eat('apple'); // "eat apple"
// 위 결과가 가능한 이유는, me에 eat()은 없지만 프로토타입 체인으로 부모가 갖고 있는 eat()을 찾아 실행했기 때문이다.

</script>
</head>
<body>
<div class="align-center" id="article">
	<h1>javascript constructor function</h1>
	<hr>
	<p>description</p>
	<button type="button">테스트용 버튼 #1</button>
</div>
</body>
</html> 